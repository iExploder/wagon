# Wagon Development Note (0x00)

## What is Wagon?

Wagon is designed as an embedded DSL for OCaml, in order to reduce misuse of Intel SIMD(Single Instruction Multiple Data) Intrinsics by enhancing type check and type inference.
C codes with Intel SIMD Intrinsics are intended to be generated by Wagon module.

Intel SIMD Intrinsics are designed for experienced C/C++ programmers,
with SIMD instructions encapsulated as declarations of C structures and C functions.

The main data types, `__m128i`, `__m256i`, `__m512i` for integers,
`__m128`, `__m256`, `__m512` for single-precision floating decimals,
and `__m128d`, `__m256d`, `__m512d` for double-precision floating decimals.
(512-bit vectors only available on enterprise market Xeon E5/E7 and consumer market architectures starting from Ice Lake(10th gen Core processors))

There is almost no problem for `float` and `double` vectors since they are just specially aligned arrays holding only **one** type of data.

For integer vectors, the declarations are listed below.

## Current Design of Wagon

Wagon is proudly designed to use tagless-final style,
generating C code with SIMD intrinsics.

### Module Types

In skeleton of WagonBasic `module type`, tagless-final style
AST builder types and functions for the limited subset of C-language
are defined.

```ocaml
module type WagonBasic =
  sig
    type wtname = string
    type 'a wterm = wtname
    type ('t, 'init) wtype = { typename : wtname; init : 'init -> wtname; }
    type wi8
    type wi16
    type wi32
    type wi64
    type wf32
    type wf64
    val wi8 : (wi8, int) wtype
    val wi16 : (wi16, int) wtype
    val wi32 : (wi32, int) wtype
    val wi64 : (wi64, int) wtype
    val wf32 : (wf32, float) wtype
    val wf64 : (wf64, float) wtype
    val warr : ('t, 'i) wtype -> int -> ('t array, 'i array) wtype
    type ('a, 'b) ws = (wtname -> 'a) -> 'b
    val typ : ('a, 'b) wtype -> ('c, 'b -> 'c) ws
    val ( <> ) : ('a, 'b) ws -> ('c, 'a) ws -> ('c, 'b) ws
    val wstruct : (wtname, wtname) ws -> wtname
  end
```

This is a partial solution which could achieve the followings.

* Type representation of scalars
* Type representation of arrays(also for vectors)
* Type representation of structures

### Next step

* Name generation of structure
  * Generation based on Hash (of type list)